# Digital Hardware Blocks

A special collection of practical digital hardware elements in Verilog.

Testbenched using Verilator in C++.

### List of Contents

- Compilation of basic gate outputs in `basic_gates.v`
- Flip Flop conversions in any file with the name containing `flip_flop`
- A shift register for both left and right shifting in `universal_shift_register.v`
- A simple 8-bit adder in `adder.v`
- A simple 2 to 1 mux in `mux.v`
- An edge detector in `edge_detector.v`
- An asynchronous reset circuit in `async_reset.v`
- A comparator circuit in `comparator.v`
- An 8 to 3 bit priority encoder in `priority_encoder.v`
- A synchronous universal up/down counter in `universal_counter.v`
- A tri-state buffer in `tri_state_buffer.v`
- A 4-bit Fibonacci sequence generator in `fibonacci.v`

### How Do I Run C++ Verilator Testbench?

Lets say we have a Verilog `module.v` and a C++ `tb_module.cpp`

On Ubuntu, at least, I run like the following: (the starting V is generated by verilator)

```
verilator -cc module.v --exe tb_module.cpp # to generate a makefile
make -C obj_dir -f Vmodule.mk Vmodule # to build the executable
./obj_dir/Vmodule 
```

### How Might I Visualize the Circuit?

Using waveforms, specifically, the GTKWave tool!

Example of a waveform on Fibonacci:

![Screenshot 2025-04-07 205205](https://github.com/user-attachments/assets/316dbfe5-8f06-4236-b371-3cc7907a9e0a)
